{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Uni","text":""},{"location":"#useful-tools","title":"Useful Tools","text":"<ul> <li>Learn Git: Learn Git Branching</li> <li>Coding Exercises: Advent of Code 2023</li> </ul>"},{"location":"#java","title":"Java","text":"<ul> <li>General<ul> <li>Java/Keywords</li> <li>Java/UML</li> </ul> </li> <li>Patterns<ul> <li>Java/Patterns/Composite Pattern</li> <li>Java/Patterns/Decorator Pattern</li> <li>Java/Patterns/FactoryMethod Pattern</li> <li>Java/Patterns/Immutable Class</li> <li>Java/Patterns/Observer Pattern</li> <li>Java/Patterns/Signleton Pattern</li> </ul> </li> <li>Frameworks<ul> <li>Java/Frameworks/Collections</li> <li>Java/Frameworks/JSON with gson</li> </ul> </li> <li>Formats<ul> <li>Java/Formats/XSD</li> </ul> </li> </ul>"},{"location":"Features/LaTeX%20Math%20Support/","title":"LaTeX Math Support","text":"<p>LaTeX math is supported using MathJax.</p> <p>Inline math looks like \\(f(x) = x^2\\). The input for this is <code>$f(x) = x^2$</code>. Use <code>$...$</code>.</p> <p>For a block of math, use <code>$$...$$</code> on separate lines</p> <pre><code>$$\nF(x) = \\int^a_b \\frac{1}{2}x^4\n$$\n</code></pre> <p>gives </p> \\[ F(x) = \\int^a_b \\frac{1}{2}x^4 \\]"},{"location":"Features/Mermaid%20Diagrams/","title":"Mermaid diagrams","text":"<p>Here's the example from MkDocs Material documentation: </p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"Features/Text%20Formatting/","title":"Text Formatting","text":"<p>You can have lists like this</p> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> <p>Or checklist lists to</p> <ul> <li> Get</li> <li> things</li> <li> done</li> </ul> <p>Also, get highlights and strikethroughs as above (similar to Obsidian).</p> <p>More formatting options for your webpage here. (but not compatible with Obsidian)</p>"},{"location":"Java/Keywords/","title":"Keywords","text":""},{"location":"Java/Keywords/#visibility","title":"Visibility","text":"<ul> <li>protected: declarations are visible within the package or all sub classes</li> <li>default: declarations are visible only within the package (package private)</li> <li>private: declarations are visible within the class only</li> <li>public: declarations are visible everywhere</li> </ul>"},{"location":"Java/Keywords/#other-useful-keywords","title":"Other useful keywords","text":"<ul> <li>super(args...): calls constructor of base class</li> <li>abstract: Class contains abstract and implemented methods, the class cannot be instantiated, it can only be subclassed</li> <li>interface: only abstract methods</li> <li>a extends b: adds everything from class b to a </li> <li>a implements b: a implements methods of interface b </li> <li>volatile: Variable is never cached, different threads see the write immediately </li> </ul>"},{"location":"Java/Keywords/#further-reading","title":"Further Reading","text":"<ul> <li>List of Java keywords - Wikipedia</li> <li>Java Language Keywords</li> </ul>"},{"location":"Java/UML/","title":"UML","text":""},{"location":"Java/UML/#uml-arrows","title":"UML Arrows","text":""},{"location":"Java/UML/#association","title":"Association","text":"<p>Associations are just relationships between classes.</p>"},{"location":"Java/UML/#aggregation-vs-composition","title":"Aggregation vs Composition","text":"<p>Aggregation and Composition are used when Classes are composed from other classes. The difference between them is in their lifetime.  Aggregation: Destroying the class does not destroy its parts Composition: Destroying the class also destroys the parts </p>"},{"location":"Java/Formats/XSD/","title":"XSD","text":"<ul> <li>Simple Element: <code>&lt;xs:element name=&lt;n&gt; type=&lt;t&gt; /&gt;</code><ul> <li>Contains a simple data type</li> <li>xs:string, xs:decimal, xs:integer, xs:boolean, xs:date, xs:time</li> </ul> </li> <li>Attribute <code>&lt;xs:attribute name=&lt;n&gt; type=&lt;t&gt;</code></li> <li>simple Type:Contains only primitive data types</li> <li>complex Type: Contains other Elements</li> </ul>"},{"location":"Java/Formats/XSD/#restrictions","title":"Restrictions","text":"<pre><code>&lt;xs:element name=\"car\"&gt;  \n\u00a0 &lt;xs:simpleType&gt;  \n\u00a0\u00a0\u00a0 &lt;xs:restriction base=\"xs:string\"&gt;  \n\u00a0\u00a0\u00a0\u00a0\u00a0 &lt;xs:enumeration value=\"Audi\"/&gt;  \n\u00a0\u00a0\u00a0\u00a0\u00a0 &lt;xs:enumeration value=\"Golf\"/&gt;  \n\u00a0\u00a0\u00a0\u00a0\u00a0 &lt;xs:enumeration value=\"BMW\"/&gt;  \n\u00a0\u00a0\u00a0 &lt;/xs:restriction&gt;  \n\u00a0 &lt;/xs:simpleType&gt;  \n&lt;/xs:element&gt;\n</code></pre> <p>This can also be written like this: <pre><code>&lt;xs:element name=\"car\" type=\"carType\"/&gt;  \n\n&lt;xs:simpleType name=\"carType\"&gt;  \n\u00a0 &lt;xs:restriction base=\"xs:string\"&gt;  \n\u00a0\u00a0\u00a0 &lt;xs:enumeration value=\"Audi\"/&gt;  \n\u00a0\u00a0\u00a0 &lt;xs:enumeration value=\"Golf\"/&gt;  \n\u00a0\u00a0\u00a0 &lt;xs:enumeration value=\"BMW\"/&gt;  \n\u00a0 &lt;/xs:restriction&gt;  \n&lt;/xs:simpleType&gt;\n</code></pre></p>"},{"location":"Java/Formats/XSD/#sequence","title":"Sequence","text":"<p><pre><code>&lt;xs:element name=\"employee\"&gt;  \n\u00a0 &lt;xs:complexType&gt;  \n\u00a0\u00a0\u00a0 &lt;xs:sequence&gt;  \n\u00a0\u00a0\u00a0\u00a0\u00a0 &lt;xs:element name=\"firstname\" type=\"xs:string\"/&gt;  \n\u00a0\u00a0\u00a0\u00a0\u00a0 &lt;xs:element name=\"lastname\" type=\"xs:string\"/&gt;  \n\u00a0\u00a0\u00a0 &lt;/xs:sequence&gt;  \n\u00a0 &lt;/xs:complexType&gt;  \n&lt;/xs:element&gt;\n</code></pre> Elements firstname and lastname are children of employee</p>"},{"location":"Java/Frameworks/Collections/","title":"Collections","text":""},{"location":"Java/Frameworks/Collections/#collections","title":"Collections","text":""},{"location":"Java/Frameworks/JSON%20with%20gson/","title":"JSON with gson","text":""},{"location":"Java/Frameworks/JSON%20with%20gson/#complex-types","title":"Complex Types","text":"<p>Abstract classes can be instanced using a TypeAdapter.</p> <p>Clique.java <pre><code>public class Clique {\n    private final List&lt;Person&gt; members = new LinkedList&lt;&gt;();\n\n    public boolean addMember(Person p) {\n        return members.add(p);\n    }\n\n    public void removeMember(int at) {\n        members.remove(at);\n    }\n}\n</code></pre></p> <p>Main.java <pre><code>public class Main {  \n    private static final GsonBuilder gsonBuilder;  \n    private static final Gson gson;  \n\n    static {  \n        gsonBuilder = new GsonBuilder();  \n        gsonBuilder.registerTypeAdapter(Person.class, new PersonAdapter());  \n        gson = gsonBuilder.create();  \n    }  \n\n    public static void main(String[] args) throws FileNotFoundException {  \n        Lad lad = gson.fromJson(new BufferedReader(new FileReader(\"resources/main/Lad.json\")), Lad.class);  \n\n        Lass lass = gson.fromJson(new BufferedReader(new FileReader(\"resources/main/Lass.json\")), Lass.class);  \n\n        Clique clique = gson.fromJson(new BufferedReader(new FileReader(\"resources/main/Clique.json\")), Clique.class);  \n    }  \n}  \n\nclass PersonAdapter implements JsonDeserializer&lt;Person&gt; {  \n    @Override  \n    public Person deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {  \n\n    var person = json.getAsJsonObject();  \n    var isFemale = person.get(\"female\").getAsBoolean();  \n    var name = person.get(\"name\").getAsString();  \n\n    if (isFemale)  \n        return new Lass(name);  \n\n    return new Lad(name);  \n    }  \n}\n</code></pre></p>"},{"location":"Java/Patterns/Composite%20Pattern/","title":"Composite Pattern","text":"<p>The Composite-Pattern represents data in a tree-like structure, and allows to treat a group of objects the same way as a single instance. </p> <p>This pattern consists of four parts: - Component: Declares the interface used for objects in the composition - Leaf: Defines behavior for objects in the composition (implements Component interface) - Composite: Stores all the child components and also implements the interface on the child components</p>"},{"location":"Java/Patterns/Composite%20Pattern/#example","title":"Example","text":""},{"location":"Java/Patterns/Composite%20Pattern/#component","title":"Component","text":"<pre><code>public interface Employee {\n    public void showDetails();\n}\n</code></pre>"},{"location":"Java/Patterns/Composite%20Pattern/#leaf","title":"Leaf","text":"<p>Developer \"leaf\": <pre><code>public class Developer implements Employee {\n    private String name;\n\n    public Developer(String name) {\n        this.name = name;\n    }\n\n    @override\n    public void showDetails() {\n        System.out.println(name);\n    }\n}\n</code></pre></p> <p>Manager \"leaf\" <pre><code>public class Manager implements Employee {\n    private String name;\n    private int money;\n\n    public Developer(String name, int money) {\n        this.name = name;\n        this.money = money;\n    }\n\n    @override\n    public void showDetails() {\n        System.out.println(name  + \" \" + money);\n    }\n}\n</code></pre></p>"},{"location":"Java/Patterns/Composite%20Pattern/#composite","title":"Composite","text":"<pre><code>public class CompanyDirectory implements Employee {\n    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;;\n\n    @override \n    public void showDetails() {\n        for(var e : employees)\n            e.showDetails();\n    }\n\n    public void addEmployee(Employee e) {\n        employees.add(e);\n    }\n}\n</code></pre>"},{"location":"Java/Patterns/Composite%20Pattern/#main-program","title":"Main Program","text":"<pre><code>public static void main(String[] args) {\n    Developer dev1 = new Developer(\"Epic Dev\");\n    Developer dev2 = new Developer(\"average java dev\");\n\n    dev2.showDetails();\n\n    CompanyDirectory devDir = new CompanyDirectory();\n    devDir.addEmployee(dev1);\n    devDir.addEmployee(dev2);\n\n    Manager man1 = new Manager(\"Very useful manager\", 20000);\n    Manager man2 = new Manager(\"Very manager\", 20010);\n\n    CompanyDirectory manDir = new CompanyDirectory();\n    manDir.addEmployee(man1);\n    manDir.addEmployee(man2);\n\n    CompanyDirectory dir = new CompanyDirectory();\n    dir.addEmployee(devDir);\n    dir.addEmployee(manDir);\n    dir.showDetails();\n}\n</code></pre>"},{"location":"Java/Patterns/Decorator%20Pattern/","title":"Decorator Pattern","text":""},{"location":"Java/Patterns/Decorator%20Pattern/#decorator-pattern","title":"Decorator-Pattern","text":"<p>The Decorator-Pattern is used to modify the functionality of a specific object at runtime. This pattern includes a Base Interface, an Implementation of that Interface, an abstract base decorator and a concrete Decorator which actually adds more functionality.</p> <p>The base decorator acts as a proxy, which enables us to add functionality before and after the actual method call.</p> <ol> <li>Component Interface: Any interface</li> <li>Component Implementation: Any Implementation of interface (1)</li> <li> <p>Base Decorator</p> <ul> <li>Has Implementation (2) as member Variable (init through constructor)</li> <li>Implements Interface (1) as well</li> </ul> </li> <li> <p>Concrete Decorator</p> <ul> <li>Extends Base Decorator (3)</li> <li>Adds additional functionality in the overridden method calls</li> </ul> </li> </ol>"},{"location":"Java/Patterns/Decorator%20Pattern/#example","title":"Example","text":"<ol> <li> <p>Component Interface <pre><code>public interface DataSource {\n    void writeData(String data);\n\n    String readData();\n}\n</code></pre></p> </li> <li> <p>Component Implementation <pre><code>public class FileDataSource implements DataSource {\n    private String name;\n\n    public FileDataSource(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void writeData(String data) {\n        File file = new File(name);\n        OutputStream out = new FileOutputStream(file)\n        out.write(data.getBytes(), 0, data.length());\n    }\n\n    @Override\n    public String readData() {\n        char[] buffer = null;\n        File file = new File(name);\n        buffer = new char[(int) file.length()];\n        reader.read(buffer);\n        return new String(buffer);\n    }\n}\n</code></pre></p> </li> <li> <p>Base Decorator <pre><code>public class DataSourceDecorator implements DataSource {\n    private DataSource wrappee;\n\n    DataSourceDecorator(DataSource source) {\n        this.wrappee = source;\n    }\n\n    @Override\n    public void writeData(String data) {\n        wrappee.writeData(data);\n    }\n\n    @Override\n    public String readData() {\n        return wrappee.readData();\n    }\n}\n</code></pre></p> </li> <li> <p>Concrete Decorator <pre><code>public class EncryptionDecorator extends DataSourceDecorator {\n\n    public EncryptionDecorator(DataSource source) {\n        super(source);\n    }\n\n    @Override\n    public void writeData(String data) {\n        // Encode functionality is added, before writeData is called\n        super.writeData(encode(data));\n    }\n\n    @Override\n    public String readData() {\n        return decode(super.readData());\n    }\n\n    private String encode(String data) {\n        byte[] result = data.getBytes();\n        // ... Do some magic ...\n        return Base64.getEncoder().encodeToString(result);\n    }\n\n    private String decode(String data) {\n        byte[] result = Base64.getDecoder().decode(data);\n        // ... Do some magic ...\n        return new String(result);\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"Java/Patterns/FactoryMethod%20Pattern/","title":"FactoryMethod Pattern","text":"<p>The FactoryMethod-Pattern is used to create objects without specifying the exact class of object that will be created. This is useful when you need to decouple the creation of an object from its implementation.</p>"},{"location":"Java/Patterns/FactoryMethod%20Pattern/#example","title":"Example","text":"<p>Basic Interface <pre><code>public interface Button {\n    public void draw();\n    public void on_pressed();\n}\n</code></pre></p> <p>Implementations <pre><code>public class LightModeButton implements Button {\n    ...\n}\n</code></pre></p> <pre><code>public class DarkModeButton implements Button {\n    ...\n}\n</code></pre> <p>Factory Now to create a Button based on the current Theme we need a Factory: <pre><code>public enum Theme {\n    DARK,\n    LIGHT\n}\n\npublic class ButtonFactory {\n    public Button createButton(Theme theme) {   \n        switch(theme) {\n            case Theme.Dark:\n                return new DarkModeButton();\n            case Theme.Light:\n                return new LightModeButton();\n        }\n    }\n}\n</code></pre></p>"},{"location":"Java/Patterns/Immutable%20Class/","title":"Immutable Class","text":"<p>In java objects are passed as references. So even if you get a member variable from Class through a Getter, you can still mutate the state of the Class! To prevent this, one can use the \"immutable class pattern\". Here you make sure that you always perform a copy when accessing or sharing data, to avoid passing references to class members.</p>"},{"location":"Java/Patterns/Immutable%20Class/#immutable-class","title":"Immutable class","text":"<ol> <li>Declare Class as final</li> <li>Make all fields private</li> <li>Don\u2018t provide setter methods</li> <li>Make all mutable fields final</li> <li>Initialize all fields using a construct method performing deep copy</li> <li>Perform cloning of objects in Getter methods to return a copy </li> </ol>"},{"location":"Java/Patterns/Observer%20Pattern/","title":"Observer Pattern","text":"<p>Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they\u2019re\u00a0observing. </p>"},{"location":"Java/Patterns/Signleton%20Pattern/","title":"Signleton Pattern","text":"<p>A Singleton is used when only a single instance of the class is needed globally. Achieve this by making the constructor private and writing a public getter which lazily initializes the instance.</p>"},{"location":"Java/Patterns/Signleton%20Pattern/#example","title":"Example","text":"<p>This is a very simple implementation. It works but is not thread safe! To achieve thread safety the get method could be marked with synchronized, or Double Checked Locking could be used for more performance. <pre><code>class Singleton {\n    private static Singleton instance;\n\n    private Singleton() {}\n\n    public static Singleton get() {\n        if(instance == null)\n            instance = new Singleton();\n        return instance;\n    }\n}\n</code></pre></p>"}]}